\documentclass[twocolumn]{article}
\usepackage[utf8]{inputenc}
\usepackage{blindtext}
\usepackage[paperheight=252mm,paperwidth=174mm,margin=1mm,heightrounded]{geometry}
\usepackage{ulem}
\usepackage{array}
\usepackage{listings}

\usepackage{minted}
%\BeforeBeginEnvironment{minted}{}
%\AfterEndEnvironment{minted}{}

\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}
\usetikzlibrary{positioning}

%% Common TikZ libraries
\usetikzlibrary{calc}

%% Custom TikZ addons
\usetikzlibrary{crypto.symbols}
\tikzset{shadows=no}        % Option: add shadows to XOR, ADD, etc.

\usepackage{color}
\definecolor{light-gray}{rgb}{0.95,0.95,0.95}
\setminted{bgcolor=light-gray}  % this line causes the problem

\setlength{\parindent}{0mm}
\setlength{\parskip}{0mm}

\tikzstyle{string} = [rectangle, rounded corners, inner sep=2mm, text centered, draw=black, fill=red!30]
\tikzstyle{bytes} = [rectangle, rounded corners, inner sep=2mm, text width=, text centered, draw=black, fill=blue!30]
\tikzstyle{int} = [rectangle, rounded corners, inner sep=2mm, text width=,  text centered, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]

\begin{document}

\title{Headless GDB Scripting}
\date{}
%\maketitle
\section*{Headless GDB Scripting}

\vspace*{-0.5\baselineskip}

Consider a simple exploitation scenario where we have a stack buffer overflow and we want to figure out at what offset of our input the value that will overwrite the return address resides. We could use our decompiler platform of choice, cross-reference the local variable usage, let it reconstruct the stack frame and compare the offset of the overflowing variable with the offset of the saved return address.

On the other hand, sending a de Bruijn sequence generated with the pwntools cyclic() function, using the instruction pointer value at the crash and calculating the offset might be easier.

Doing this manually is all well and good and can be accomplished in a few minutes but what if you want to do this in an automated or "headless" fashion? While we do not yet live in a utopia with an API-first headless scriptable debugger\footnote{Someone please build this} we can make a workable hack.

\vspace*{-0.5\baselineskip}
\subsection*{Scripting GDB}

As long as we are on a platform supported by GDB we can accomplish this by using its Python API. The first step is to start the process and attach GDB

\begin{minted}{python}
from pwn import *
io = process("./exercise", level="debug")
_, gdb_api = gdb.attach(io, api=True)
\end{minted}

Now we can attach an event handler to the "stop" event which fires among, other things, when a segfault is triggered.

\begin{minted}{python}
...
def stop_handler(event):
  print('program stopped')
gdb_api.events.stop.connect(stop_handler)
\end{minted}

If we then make the program crash we can access register values from this handler

\begin{minted}{python}
...
def stop_handler(event):
  frame = self.gdb.selected_frame()
  rsp = int(frame.read_register("rsp"))
  process = self.gdb.selected_inferior()
  ret = process.read_memory(rsp, 8)
  offset = cyclic_find(ret.tobytes()[:4])
...
\end{minted}

\vspace*{-0.5\baselineskip}
\subsection*{Linearizing the flow}

Now, since this is event-driven we might want to add some plumbing to make the rest of the code wait for the result to come back. We do this by using the fact that any callable can be passed as an event handler together with a semaphore.

\begin{minted}{python}
class GdbExtractor:
  def __init__(self, gdb):
    self.semaphore = threading.Semaphore(0)
    self.gdb = gdb
    self.retaddr = None

  def __call__(self, event):
    self.retaddr = self.gdb...
    self.semaphore.release()
...
extractor = GdbExtractor(gdb_api)
gdb_api.events.stop.connect(extractor)
gdb_api.execute("continue")
...
extractor.semaphore.acquire()
print(f'Ret: {extractor.retaddr}')
\end{minted}

For this to work fully headless you might need to adjust the terminal. If you are using pwntools, you can do this like this:

\begin{minted}{python}
context.terminal = [
  "python3",
  os.path.join(
    os.path.dirname(pwnlib.__file__),
    "gdb_faketerminal.py"
  ),
]
_, gdb_api = gdb.attach(io, api=True)
context.terminal = None
\end{minted}

\vspace*{-0.5\baselineskip}
\subsection*{Nested events gotchas}

If you want to issue commands to GDB, you can do this with the .execute() method but there is a small caveat if you are doing this from within an event handler. If you call "continue" from the event handler it will not work, however we can again take advantage of the fact that you can pass a callable

\begin{minted}{python}
# inside an event handler
# you have to do this
def stop_handler(event):
  f=lambda:gdb.execute('continue')
  gdb.execute(f)

# outside an event handler
# this is enough
gdb.execute('continue')
\end{minted}

Now, why would we want this? Personally, the problem arose when I was building "unit tests" to a series of introductory CTF challenges I had built. I wanted my solve scripts to be able to solve the challenges even if they were rebuilt in such a way that the stack layout happened to change or even work for multiple architectures. One could also imagine this being useful for unit or integration tests in a exploit development shop.

%\vfill\null
\end{document}
